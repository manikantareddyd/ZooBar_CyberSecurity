#
# [file:#lines]
# desc
#
[http.c:30]
1. It can be seen that size of buffer is not checked and simply everything is copied from *buf and so on. Given sufficiently long input entire stack can be over written by input for buf.
    int http_read_line(int fd, char *buf, size_t size)
    {
        size_t i = 0;

        for (;;)
        {
            int cc = read(fd, &buf[i], 1);
            if (cc <= 0)
                break;

            if (buf[i] == '\r')
            {
                buf[i] = '\0';      /* skip */
                continue;
            }

            if (buf[i] == '\n')
            {
                buf[i] = '\0';
                return 0;
            }

            if (i >= size - 1)
            {
                buf[i] = '\0';
                return 0;
            }

            i++;
        }

        return -1;
    }

[http.c:65]
2. The above bug[http.c:30] allows us to overflow the buffer and reqrite crucial stuff like the file descriptor, due to which the server crashes. This can be prevented by the use of canaries as the buffer 'buf' is just below %ebp any change in canary can be detected.
-----------------------------------------------
Buggy Code
    if (http_read_line(fd, buf) < 0)
        return "Socket IO error";
-----------------------------------------------
Exploit
    "GET /" + "A" (x times) + "HTTP/1.0\r\n\r\n" 

Here x depends on other variables
------------------------------------------------


[http.c:121]
3. The above bug[http.c:30] allows us to overflow the buffer of headers and reqrite crucial stuff like the return address, due to which the server crashes. This can be prevented by the use of canaries as the buffer 'buf' is just below %ebp any change in canary can be detected.
-----------------------------------------------
Buggy Code
    if (http_read_line(fd, buf) < 0)
        return "Socket IO error";
-----------------------------------------------
Exploit
    "GET / HTTP/1.0\r\n Cookie: " + (malicious code) + "\r\n\r\n" 

------------------------------------------------

[http.c:397]
4. The above bug[http.c:30] allows us to overflow the buffer. But this function is called by the server and is not as exciting. 
-------------------------------------------------------
Buggy Code
    if (http_read_line(pipefd[0], buf) < 0) {
                http_err(fd, 500, "Premature end of script headers");
                close(pipefd[0]);
                return;
            }
-------------------------------------------------------
Exploit
    Cannot be exploited
-------------------------------------------------------

[http.c:274]
5. Insecure use of strcat. The 'name' buffer can be of length 2048. Its being concatenated to 'pn' buffer of size 1024. Buffer overflow possible. 
Attack on this can go unnoticed by canaries, as the function pointer we wish to exploit is below ebp.
-------------------------------------------------------
Buggy Code
    strcat(pn, name);
-------------------------------------------------------
Exploit
    "GET /" + (Malicious function pointers) + "HTTP/1.0\r\n\r\n"
-------------------------------------------------------

6. [http.c:88]
Vulnerable buffer 'env'. Server protocol could be a string of arbitrary length, flooding the envp/env buffer. This leads to overflow at [zookd.c:71]. Can be prevented by canaries as env is above ebp.
-------------------------------------------------------
Buggy Code
    envp += sprintf(envp, "SERVER_PROTOCOL=%s", sp2) + 1;
-------------------------------------------------------
Exploit
    "GET /A" + (malicious stuff) +"\r\n\r\n"
-------------------------------------------------------

[http.c:94]
7. Vulnerable buffer 'env'. Server protocol could be a string of arbitrary length, flooding the envp/env buffer. This leads to overflow at [zookd.c:71]. Can be prevented by canaries as env is above ebp.
-------------------------------------------------------
Buggy Code
    envp += sprintf(envp, QUERY_STRING=%s", qp + 1) + 1;
-------------------------------------------------------
Exploit
    "GET /A?" + (malicious query params) + "HTTP/1.0\r\n\r\n"
-------------------------------------------------------
